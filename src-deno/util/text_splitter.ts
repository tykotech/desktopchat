// src-deno/util/text_splitter.ts\nexport class RecursiveCharacterTextSplitter {\n  private chunkSize: number;\n  private chunkOverlap: number;\n  private separators: string[];\n\n  constructor(options: { chunkSize?: number; chunkOverlap?: number; separators?: string[] } = {}) {\n    this.chunkSize = options.chunkSize || 1000;\n    this.chunkOverlap = options.chunkOverlap || 200;\n    this.separators = options.separators || [\"\\n\\n\", \"\\n\", \" \", \"\"];\n  }\n\n  async splitText(text: string): Promise<string[]> {\n    return this.splitTextRecursive(text, this.separators);\n  }\n\n  private async splitTextRecursive(text: string, separators: string[]): Promise<string[]> {\n    const finalChunks: string[] = [];\n\n    // Find the appropriate separator to split on\n    let separator = separators[separators.length - 1];\n    for (const sep of separators) {\n      if (text.includes(sep)) {\n        separator = sep;\n        break;\n      }\n    }\n\n    const splits = text.split(separator);\n    let currentChunk = \"\";\n\n    for (const split of splits) {\n      const prospectiveChunk = currentChunk ? currentChunk + separator + split : split;\n\n      if (prospectiveChunk.length > this.chunkSize) {\n        if (currentChunk) {\n          finalChunks.push(currentChunk);\n        }\n        if (prospectiveChunk.length > this.chunkSize) {\n          // Recursively split the large chunk\n          const recursiveChunks = await this.splitTextRecursive(prospectiveChunk, separators.slice(1));\n          finalChunks.push(...recursiveChunks);\n          currentChunk = \"\";\n        } else {\n          currentChunk = prospectiveChunk;\n        }\n      } else {\n        currentChunk = prospectiveChunk;\n      }\n    }\n\n    if (currentChunk) {\n      finalChunks.push(currentChunk);\n    }\n\n    // Handle overlap\n    if (this.chunkOverlap > 0) {\n      return this.handleOverlap(finalChunks);\n    }\n\n    return finalChunks;\n  }\n\n  private handleOverlap(chunks: string[]): string[] {\n    if (chunks.length <= 1) {\n      return chunks;\n    }\n\n    const overlappedChunks: string[] = [chunks[0]];\n\n    for (let i = 1; i < chunks.length; i++) {\n      const prevChunk = overlappedChunks[overlappedChunks.length - 1];\n      const currentChunk = chunks[i];\n\n      // Find the overlap\n      const overlap = prevChunk.slice(-this.chunkOverlap);\n      const overlappedChunk = overlap + currentChunk;\n\n      overlappedChunks.push(overlappedChunk);\n    }\n\n    return overlappedChunks;\n  }\n}